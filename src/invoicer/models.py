"""
Pydantic models for the invoicer application.

This module defines data models for clients, invoices, and other entities.
"""

from datetime import datetime
from typing import Annotated, Optional
from uuid import uuid4
from pydantic import (
    BaseModel,
    ConfigDict,
    EmailStr,
    Field,
    BeforeValidator,
    AfterValidator,
    field_validator,
    field_serializer,
)


# ============================================================================
# Helper functions
# ============================================================================

def strip_whitespace(value: str) -> str:
    """Strip leading and trailing whitespace."""
    return value.strip()

def uppercase_transform(value: str) -> str:
    """Transform string to uppercase."""
    return value.upper().strip()

def validate_non_empty_after_strip(value: str) -> str:
    """Validate that string is not empty after stripping whitespace."""
    if not value:
        raise ValueError("Field cannot be empty")
    return value


def generate_uuid() -> str:
    """Generate a UUID4 string for unique identifiers."""
    return str(uuid4())
    

# ============================================================================
# Single-use field types for models.py
# ============================================================================


ClientEmailField = Annotated[
    EmailStr,
    Field(description="Client email address for invoice delivery"),
]


# ID and identifier fields used only in models
UniqueIdField = Annotated[
    str,
    Field(description="Unique identifier"),
]

AutoGeneratedIdField = Annotated[
    str,
    Field(default_factory=generate_uuid, description="Auto-generated unique identifier"),
]

ClientCodeField = Annotated[
    str,
    BeforeValidator(uppercase_transform),
    Field(
        min_length=1,
        max_length=10,
        description="Client code for invoices (automatically converted to uppercase)",
    ),
]

# String fields used only in models
OptionalTextField = Annotated[
    Optional[str],
    BeforeValidator(lambda v: v.strip() if v else None),
    Field(default=None, description="Optional text field"),
]

OptionalNotesField = Annotated[
    Optional[str],
    BeforeValidator(lambda v: v.strip() if v else None),
    Field(default="", description="Additional notes or comments"),
]

ClientNameField = Annotated[
    str,
    BeforeValidator(strip_whitespace),
    AfterValidator(validate_non_empty_after_strip),
    Field(min_length=1, description="Client or company name"),
]

InvoiceNumberField = Annotated[
    str,
    BeforeValidator(strip_whitespace),
    AfterValidator(validate_non_empty_after_strip),
    Field(min_length=1, description="Unique invoice number"),
]

ProjectNameField = Annotated[
    str,
    BeforeValidator(strip_whitespace),
    AfterValidator(validate_non_empty_after_strip),
    Field(min_length=1, description="Project name or identifier"),
]

ServiceDescriptionField = Annotated[
    str,
    BeforeValidator(strip_whitespace),
    AfterValidator(validate_non_empty_after_strip),
    Field(min_length=1, description="Service or item description"),
]

UnitTypeField = Annotated[
    str,
    BeforeValidator(strip_whitespace),
    Field(default="days", description="Unit type (days, hours, items, etc.)"),
]

PaymentTermsField = Annotated[
    str,
    BeforeValidator(strip_whitespace),
    Field(
        default="Payment is due within 30 days of invoice date. Late payments may incur additional charges.",
        description="Payment terms and conditions",
    ),
]

# Numeric fields used only in models
QuantityField = Annotated[
    float,
    Field(gt=0, description="Quantity (days, hours, items, etc.)"),
]

RateField = Annotated[
    float,
    Field(gt=0, description="Rate per unit"),
]

AmountField = Annotated[
    float,
    Field(ge=0, description="Monetary amount"),
]

TaxRateField = Annotated[
    float,
    Field(ge=0, le=1, description="Tax rate as decimal (0.0 to 1.0)"),
]

TotalAmountField = Annotated[
    float,
    Field(ge=0, description="Total amount due"),
]

InvoiceCountField = Annotated[
    int,
    Field(default=0, ge=0, description="Number of invoices"),
]

DaysWorkedField = Annotated[
    Optional[int],
    Field(default=None, ge=0, description="Number of days worked"),
]

NonNegativeFloatField = Annotated[
    float,
    Field(ge=0, description="Non-negative floating point number"),
]

SubtotalField = Annotated[
    float,
    Field(ge=0, description="Subtotal amount before tax"),
]

TaxAmountField = Annotated[
    float,
    Field(ge=0, description="Tax amount in currency"),
]

# Date fields used only in models
AutoDateTimeField = Annotated[
    datetime,
    Field(default_factory=datetime.now, description="Auto-generated timestamp"),
]

OptionalDateTimeField = Annotated[
    Optional[datetime],
    Field(default=None, description="Optional date and time"),
]

InvoiceDateField = Annotated[
    datetime,
    Field(default_factory=datetime.now, description="Invoice date"),
]

DueDateField = Annotated[
    str,
    Field(default="Net 30 days", description="Due date description"),
]

# Contact fields used only in models
PhoneField = Annotated[
    Optional[str],
    Field(default="", description="Phone number with international format support"),
]

# List fields used only in models
ProjectIdListField = Annotated[
    list[str],
    Field(
        default_factory=list,
        description="List of project IDs associated with this entity",
    ),
]

class ProjectModel(BaseModel):
    """Pydantic model for project data using standardized field types."""

    id: AutoGeneratedIdField
    name: ProjectNameField
    client_id: UniqueIdField
    created_date: AutoDateTimeField

    @field_validator("name")
    def validate_name(cls, v):
        """Ensure name is not empty string"""
        if not v.strip():
            raise ValueError("Project name cannot be empty")
        return v.strip()

    @field_serializer("created_date")
    def serialize_datetime(self, v: datetime) -> str:
        """Serialize datetime fields to ISO format"""
        return v.isoformat()

    model_config = ConfigDict(
        validate_assignment=True,
    )


class ClientSummaryModel(BaseModel):
    """Simplified client model for listings and summaries using standardized field types."""

    id: AutoGeneratedIdField
    name: ClientNameField
    email: ClientEmailField
    client_code: ClientCodeField
    created_date: AutoDateTimeField
    projects: ProjectIdListField
    last_invoice_date: OptionalDateTimeField = None
    total_invoices: InvoiceCountField = 0


class ClientModel(ClientSummaryModel):
    """Pydantic model for client data using standardized field types."""

    # Additional fields beyond the summary
    address: str
    phone: PhoneField
    notes: OptionalNotesField = ""
    total_amount: NonNegativeFloatField = 0.0

    @field_validator("client_code")
    def validate_client_code(cls, v):
        """Ensure client code is uppercase"""
        return v.upper()

    @field_validator("name")
    def validate_name(cls, v):
        """Ensure name is not empty string"""
        if not v.strip():
            raise ValueError("Name cannot be empty")
        return v.strip()

    @field_serializer("created_date", "last_invoice_date")
    def serialize_datetime(self, v: Optional[datetime]) -> Optional[str]:
        """Serialize datetime fields to ISO format"""
        return v.isoformat() if v else None

    model_config = ConfigDict(
        validate_assignment=True,
    )


class InvoiceItemModel(BaseModel):
    """Pydantic model for individual invoice line items using standardized field types."""

    description: ServiceDescriptionField
    quantity: QuantityField
    unit_type: UnitTypeField = "days"
    rate: RateField
    amount: AmountField

    @field_validator("amount")
    def validate_amount_matches_calculation(cls, v, info):
        """Ensure amount matches quantity * rate"""
        values = info.data
        if "quantity" in values and "rate" in values:
            expected_amount = values["quantity"] * values["rate"]
            if (
                abs(v - expected_amount) > 0.01
            ):  # Allow for small floating point differences
                raise ValueError(
                    f"Amount {v} doesn't match quantity {values['quantity']} * rate {values['rate']} = {expected_amount}"
                )
        return round(v, 2)


class InvoiceClientInfoModel(BaseModel):
    """Client information embedded in invoice data using standardized field types."""

    name: ClientNameField
    client_id: str
    client_code: ClientCodeField
    email: ClientEmailField
    address: str


class InvoiceModel(BaseModel):
    """Pydantic model for invoice data using standardized field types."""

    invoice_number: InvoiceNumberField
    invoice_date: InvoiceDateField
    due_date: DueDateField = "Net 30 days"

    # Client information
    client_info: InvoiceClientInfoModel

    # Invoice items
    line_items: list[InvoiceItemModel] = []

    # Legacy support for days-based invoicing
    days_worked: DaysWorkedField = None
    project_description: OptionalTextField = None
    period: OptionalTextField = None

    # Financial details
    subtotal: SubtotalField
    tax_rate: TaxRateField = 0.0
    tax_amount: TaxAmountField = 0.0
    total_amount: TotalAmountField

    # Terms and notes
    payment_terms: PaymentTermsField
    thank_you_note: OptionalTextField = None

    @field_validator("tax_amount")
    def validate_tax_amount(cls, v, info):
        """Ensure tax amount matches subtotal * tax_rate"""
        values = info.data
        if "subtotal" in values and "tax_rate" in values:
            expected_tax = values["subtotal"] * values["tax_rate"]
            if (
                abs(v - expected_tax) > 0.01
            ):  # Allow for small floating point differences
                raise ValueError(
                    f"Tax amount {v} doesn't match subtotal {values['subtotal']} * tax_rate {values['tax_rate']} = {expected_tax}"
                )
        return round(v, 2)

    @field_validator("total_amount")
    def validate_total_amount(cls, v, info):
        """Ensure total amount matches subtotal + tax_amount"""
        values = info.data
        if "subtotal" in values and "tax_amount" in values:
            expected_total = values["subtotal"] + values["tax_amount"]
            if (
                abs(v - expected_total) > 0.01
            ):  # Allow for small floating point differences
                raise ValueError(
                    f"Total amount {v} doesn't match subtotal {values['subtotal']} + tax_amount {values['tax_amount']} = {expected_total}"
                )
        return round(v, 2)

    @field_validator("subtotal")
    def validate_subtotal_matches_line_items(cls, v, info):
        """Ensure subtotal matches sum of line items (if line_items exist)"""
        values = info.data
        if "line_items" in values and values["line_items"]:
            expected_subtotal = sum(item.amount for item in values["line_items"])
            if (
                abs(v - expected_subtotal) > 0.01
            ):  # Allow for small floating point differences
                raise ValueError(
                    f"Subtotal {v} doesn't match sum of line items {expected_subtotal}"
                )
        return round(v, 2)

    @field_serializer("invoice_date")
    def serialize_datetime(self, v: datetime) -> str:
        """Serialize datetime fields to ISO format"""
        return v.isoformat()

    model_config = ConfigDict(
        validate_assignment=True,
    )


class InvoiceSummaryModel(BaseModel):
    """Simplified invoice model for listings and summaries using standardized field types."""

    invoice_number: InvoiceNumberField
    invoice_date: InvoiceDateField
    client_name: ClientNameField
    client_id: OptionalTextField = None
    total_amount: TotalAmountField
    due_date: DueDateField
